
// Generated by Cadence Genus(TM) Synthesis Solution 20.11-s111_1
// Generated on: Mar 26 2025 10:18:27 IST (Mar 26 2025 04:48:27 UTC)

// Verification Directory fv/reg4bit 

module bmux(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module mux2x1(in0, in1, sel, out);
  input in0, in1, sel;
  output out;
  wire in0, in1, sel;
  wire out;
  bmux mux_8_18(.ctl (sel), .in_0 (in0), .in_1 (in1), .z (out));
endmodule

module dff(clk, D, Q);
  input clk, D;
  output Q;
  wire clk, D;
  wire Q;
  CDN_flop Q_reg(.clk (clk), .d (D), .sena (1'b1), .aclr (1'b0), .apre
       (1'b0), .srl (1'b0), .srd (1'b0), .q (Q));
endmodule

module reg4bit(D, t, clk, enable, Q);
  input [3:0] D;
  input t, clk, enable;
  output [3:0] Q;
  wire [3:0] D;
  wire t, clk, enable;
  wire [3:0] Q;
  wire [3:0] mux_out;
  wire \reg_gen[0].inverted_D , \reg_gen[1].inverted_D ,
       \reg_gen[2].inverted_D , \reg_gen[3].inverted_D ;
  mux2x1 \reg_gen[0].mux (.in0 (Q[0]), .in1 (\reg_gen[0].inverted_D ),
       .sel (enable), .out (mux_out[0]));
  dff \reg_gen[0].flip_flop (.clk (clk), .D (mux_out[0]), .Q (Q[0]));
  mux2x1 \reg_gen[1].mux (.in0 (Q[1]), .in1 (\reg_gen[1].inverted_D ),
       .sel (enable), .out (mux_out[1]));
  dff \reg_gen[1].flip_flop (.clk (clk), .D (mux_out[1]), .Q (Q[1]));
  mux2x1 \reg_gen[2].mux (.in0 (Q[2]), .in1 (\reg_gen[2].inverted_D ),
       .sel (enable), .out (mux_out[2]));
  dff \reg_gen[2].flip_flop (.clk (clk), .D (mux_out[2]), .Q (Q[2]));
  mux2x1 \reg_gen[3].mux (.in0 (Q[3]), .in1 (\reg_gen[3].inverted_D ),
       .sel (enable), .out (mux_out[3]));
  dff \reg_gen[3].flip_flop (.clk (clk), .D (mux_out[3]), .Q (Q[3]));
  and g1 (\reg_gen[0].inverted_D , t, D[0]);
  and g2 (\reg_gen[1].inverted_D , t, D[1]);
  and g3 (\reg_gen[2].inverted_D , t, D[2]);
  and g4 (\reg_gen[3].inverted_D , t, D[3]);
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
